# Submission for Group 17
# Kaustubh Hiware 14CS30011
# Rameshwar Bhaskaran 14CS30027
# Supposed to print all fibonacci strings upto n
.data
	prompt:   	.asciiz "Enter an integer m (no less than 2): "
	newline:   	.asciiz "\n"
	space:   	.asciiz " "
	stage_i:   	.asciiz "S[ "
	stage_close: 	.asciiz " ]: "
	stage0:		.asciiz "0\n"
	stage1:		.asciiz "01\n"
	formatter: 	.space 512 #512 bytes for strings
	s3kyahai:	.asciiz "s3  = "
	doosra:		.asciiz "Move on to the next part : \n"
	doneStr:	.asciiz "Welcome to done !\n"
	fillInstr:	.asciiz "Back to fillin'\n"
	doneStr2:	.asciiz "Print kar diya mein string , abhi ja !"
.text
.globl main
main:	li $v0 , 4       	 # loads the value 4 into register $v0 which is the code for print string
    	la $a0 , prompt    	 # load address prompt from memory and store it into arguement register 0
    	syscall          	 # reads register $v0 for op code, sees 4 and prints the string located in $a0
    	li $v0 , 5         	 # load memory for input
    	syscall            	 # ask for input n
    	
   	move $t0, $v0		 # create a local copy for printing the number
   	la $t1, ($t0)		# keep a copy of n  =>   $t1 is n
   	addu $t0,$t0,1		# numbers from 0 1, 2, 3 , ...n
	sll $t0,$t0,2		# multiply by four for memory
	 
	 
	move $fp, $sp		# keep a safe copy
	addu $sp, $sp , $t0	# dynamically allocate memory to stack pointer
				# loop initiate for filling array
	
#	la $t2, stage0
#	la $t4, 0
#	jal printStage
	
#	la $t2, stage1
#	la $t4, 1
#	jal printStage
	
	j initials
	#li $v0,10 		# return back
	#syscall

printStage:			## Print stage [ $s0 ]  = 0($t2)
	li $v0, 4
	la $a0, stage_i
	syscall
	
	li $v0, 1
	move $a0, $s0		# which stage
	syscall
	
	li $v0, 4
	la $a0, stage_close
	syscall
	
	
	#move $a0, $t3
	la $a0, 0($t2)	# what string
	syscall
		
	li $v0,5
	la $a0, newline
	#syscall
	jr $ra

initials:
    	sw   $fp, 0($sp)	# Backup return address and fp on stack.
   	sw   $ra, 4($sp)
   	addi $fp, $sp, 8
    	move $sp, $fp
    	
	
	move $s0, $zero		# i = 0  $s0 is i    	
    	move $t2,$sp		# t2 for changing the elements
    	la  $t3, stage0		# initial setting first and second strings
	#jal printStage	
	move $s1, $t3		# update for further loops
	
	move $t2, $t3
	jal printStage
	addi $t2, $t2, 4
	
	addi $s0,$s0,1
	la $t3, stage1
	#jal printStage
	move $s2, $t3		#update for further loops	
	
	move $t2, $t3
	jal printStage
	addi $t2, $t2, 4		# go to next element

  	j fillIn

fillIn:				## fill the array accordingly
	bge $s0, $t1, exit	# if i > n , exit the program

	la $s3, formatter
	jal strcpy		#gives us a string at s3 which is the current concatenation
	
	
	li $v0,4
	la $a0, fillInstr
	syscall 
	move $t2, $s3		# save concat at proper location
	
	move $s1, $s2		# update for next loop
	move $s2, $s3
				
				# printing and adding done at sDone
	addi $t2, $t2, 4	# go to next stage
	
	j fillIn		# recursion


updates3:	
				## print s3 ka value
	li $v0, 4
	la $a0, s3kyahai
	syscall
	 
	move $a0, $s3
	la $a1, 512
	syscall 
		
	li $v0,5
	la $a0, newline
	syscall
	
	jr $ra
	
strcpy:				## effective operation : concatenates strings at s2 and s1 and saves it at s3

    li $s5 10 #store newline in $s5
    	la $t4, formatter
    	la $t5, formatter
    	la $t6, formatter    	
	move $t4, $s1
	move $t5, $s2
	move $t6, $s3
    #loop through first string and copy to output string
   sCopyFirst:

        lb   $s4 0($t5)
        beq  $s4 $zero sCopySpace #exit loop on null byte
        beq  $s4 $s5 sCopySpace   #exit loop on new-line
        sb   $s4 0($t6)
        addi $t5 $t5 1
        addi $t6 $t6 1
        jal updates3
        j sCopyFirst

    sCopySpace:

        li   $s4 ' '
        j sCopySecond
       # sb   $t0 0($a2)
        #addi $a2 $a2 1 

    #loop through second string and copy to output string 
    sCopySecond:

	li $v0, 4
	la $a0, doosra		# move on to next part
	syscall

        lb   $s4 0($t4)
        beq  $s4 $zero sDone #exit on null byte
        beq  $s4 $s5 sDone   #exit on new-line
        sb   $s4 0($t6)
        addi $t4 $t4 1
        addi $t6 $t6 1
        jal updates3        
        j sCopySecond

returnKar :		
	jr $ra  			# what the name says
	
    sDone:	
	li $v0, 4
	la $a0,doneStr
	syscall
	addi $s0, $s0, 1
	sb $zero 0($t6) #null terminate string
	jal printStage
      
          li $v0,4
	la $a0, doneStr2
	syscall 
		li $v0,5
	la $a0, newline
	syscall
#	Hope this works , fillIn ka code yaha daal diya
	
	li $v0,4
	la $a0, fillInstr
	syscall 
	move $t2, $s3		# save concat at proper location
	
	move $s1, $s2		# update for next loop
	move $s2, $s3
				
				# printing and adding done at sDone
	addi $t2, $t2, 4	# go to next stage
	
	j fillIn		# recursion
#              
        jr $ra

exit:	
	li $v0,10
	syscall