# Submission for Group 17
# Kaustubh Hiware 14CS30011
# Rameshwar Bhaskaran 14CS30027
# Supposed to print all fibonacci strings upto n
.data
	prompt:   	.asciiz "Enter an integer m (no less than 2): "
	newline:   	.asciiz "\n"
	space:   	.asciiz " "
	stage_i:   	.asciiz "S[ "
	stage_close: 	.asciiz " ]: "
	stage0:		.asciiz "0\n"
	stage1:		.asciiz "01\n"
	formatter: 	.space 512 #512 bytes for strings
	s7_str:	.asciiz "s7  = "
	a2_str:	.asciiz "a2  = "
	s1_str:	.asciiz "s1  = "
	doosra:		.asciiz "Move on to the next part : \n"
	doneStr:	.asciiz "Welcome to done !\n"
	doneStr2:	.asciiz "String for this stage has been printed !"
	utlimate:	.space 255
	penutlimate:	.space 255
	current:	.space 255	
.text
.globl main
main:	li $v0 , 4       	 # loads the value 4 into register $v0 which is the code for print string
    	la $a0 , prompt    	 # load address prompt from memory and store it into arguement register 0
    	syscall          	 # reads register $v0 for op code, sees 4 and prints the string located in $a0
    	li $v0 , 5         	 # load memory for input
    	syscall            	 # ask for input n
    	
   	move $t0, $v0		 # create a local copy for printing the number
   	la $t1, ($t0)		# keep a copy of n  =>   $t1 is n
   	addu $t0,$t0,1		# numbers from 0 1, 2, 3 , ...n
	sll $t0,$t0,2		# multiply by four for memory
	# supposedly , this shouldn't work as length could be upto 255
#	mulou $t0 ,$t0,255
	 
	move $fp, $sp		# keep a safe copy
	move $t7,$sp
	addu $sp, $sp , $t0	# dynamically allocate memory to stack pointer
				# loop initiate for filling array
	
#	la $t2, stage0
#	la $t4, 0
#	jal printStage
	
#	la $t2, stage1
#	la $t4, 1
#	jal printStage
	
	j initials
	#li $v0,10 		# return back
	#syscall

printStage:			## Print stage [ $s0 ]  = 0($t2)
	li $v0, 4
	la $a0, stage_i
	syscall
	
	li $v0, 1
	move $a0, $s0		# which stage
	syscall
	
	li $v0, 4
	la $a0, stage_close
	syscall
	
	
	#move $a0, $t3
	la $a0, 0($t2)	# what string
	syscall
		
	li $v0,5
	la $a0, newline
	#syscall
	jr $ra

initials:
    	sw   $fp, 0($sp)	# Backup return address and fp on stack.
   	sw   $ra, 4($sp)
   	addi $fp, $sp, 8
    	move $sp, $fp
    	
	
	move $s0, $zero		# i = 0  $s0 is i    	
    	move $t2,$t7		# t2 for changing the elements
    	la  $t3, stage0		# initial setting first and second strings
	#jal printStage	
	
	la $s6,0
	la $s7, formatter($s6)
	la $a2, formatter($s6)
	la $s1, formatter($s6)	
	move $s1, $t3		# update for further loops
	
	move $t2, $t3

	jal printStage
	addi $t2, $t2, 4
	
	addi $s0,$s0,1
	la $t3, stage1
	#jal printStage
	move $a2, $t3		#update for further loops	
	
	move $t2, $t3
	jal printStage
	addi $t2, $t2, 4		# go to next element

  	j fillIn

fillIn:				## fill the array accordingly
	bge $s0, $t1, exit	# if i > n , exit the program

	la $s6,0
	la $s7, formatter($s6)
	#la $s7,0		# this does not work
	jal strcpy		#gives us a string at s7 which is the current concatenation
	
	## code below this line in fillIn shifted to sDone
#	move $t2, $s7		# save concat at proper location
#	
#	move $s1, $a2		# update for next loop
#	move $a2, $s7
#				
#				# printing and adding done at sDone
#	addi $t2, $t2, 4	# go to next stage
#	
#	j fillIn		# recursion
#

updates7:	
				## print s7 ka value
	li $v0, 4
	la $a0, s7_str
	syscall
	 
	move $a0, $s7
	la $a1, 512
	syscall 
		
	li $v0,5
	la $a0, newline
	syscall
	
	li $v0, 4
	la $a0, a2_str
	syscall
	 
	move $a0, $a2
	la $a1, 512
	syscall 
		
	li $v0,5
	la $a0, newline
	syscall

	li $v0, 4
	la $a0, s1_str
	syscall
	 
	move $a0, $s1
	la $a1, 512
	syscall 
		
	li $v0,5
	la $a0, newline
	syscall
	jr $ra
	
strcpy:				## effective operation : concatenates strings at a2 and s1 and saves it at s7

    	li $s5 10 #store newline in $s5
    	li $s6, 0
    	la $t4, formatter
    	la $t5, formatter
    	la $t6, formatter($s6)    	
	move $t4, $s1
	move $t5, $a2
	move $t6, $s7
    #loop through first string and copy to output string
   sCopyFirst:

        lb   $s4 0($t5)
        beq  $s4 $zero sCopySpace #exit loop on null byte
        beq  $s4 $s5 sCopySpace   #exit loop on new-line
        sb   $s4 0($t6)
        addi $t5 $t5 1
        addi $t6 $t6 1
        jal updates7		# this hasn't given any trouble yet , so ignore here         
        j sCopyFirst

    sCopySpace:

        li   $s4 ' '
       # move $s1,$a2
        j sCopySecond

    #loop through second string and copy to output string 
    sCopySecond:

	li $v0, 4
	la $a0, doosra		# move on to next part
	syscall
	jal updates7
	#lw $t7,($a2)
        lb   $s4 0($t4)
        beq  $s4 $zero sDone #exit loop on null byte
        beq  $s4 $s5 sDone   #exit loop on new-line
        sb   $s4 0($t6)
        addi $t4 $t4 1
        addi $t6 $t6 1
	#sw $t7,($a2)
        jal updates7		
        j sCopySecond

returnKar :		
	jr $ra  			# what the name says
	
    sDone:	
	li $v0, 4
	la $a0,doneStr
	syscall
	#sb $zero 0($t6)
	
	#la $s6, newline			# load address is the approach
	li $s6, 10		# newline character
	addi $s0, $s0, 1
	sb $s6 0($t6) 	#null terminate string - need to end with \n not \0 !
	jal updates7
	
#	fillIn code put here to update and print

	move $t2, $s7		# save concat at proper location
	jal printStage
				# NOTE : can't move $a2 to $s1 , that means a2 and s1 link !
	#la $a2, 0($t2)		# update for next loop
	#la $s1, -4($t2)
	lw $s1,0($a2)
	lw $a2,0($s7)
				
	addi $t2, $t2, 4	# go to next stage
      
        li $v0,4
	la $a0, doneStr2
	syscall 
	jal updates7
	
		li $v0,5
	la $a0, newline
	syscall	
	j fillIn		# recursion
#              
        jr $ra

exit:	
	li $v0,10
	syscall
